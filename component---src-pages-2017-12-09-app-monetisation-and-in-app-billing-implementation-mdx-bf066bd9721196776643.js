(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{"9QiH":function(e,t,n){"use strict";n.r(t),n.d(t,"_frontmatter",(function(){return o})),n.d(t,"default",(function(){return s}));var i=n("zLVn"),a=(n("q1tI"),n("7ljp")),o={slug:"2017-12-09-App-monetisation-and-In-App-Billing-implementation",title:"App monetisation and In-App Billing in Android.",date:"2017-12-08 19:30 +1100",categories:"post"},r={_frontmatter:o};function s(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(a.b)("wrapper",Object.assign({},r,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("div",{className:"blogpage"},Object(a.b)("a",{href:"/blog",smooth:!0,duration:1e3},"Back")),Object(a.b)("div",{className:"blogText"},Object(a.b)("h1",null,"Android apps and monetisation."),Object(a.b)("br",null),Object(a.b)("br",null),Object(a.b)("p",null,"Some devs make apps for fun, some make them for learning things. But if you've got a good app idea, chances are you want to be able to monetise it. With Android, there are several ways of going about it i.e. putting in ads - which relies on not only high volumes of downloads but large amounts of ad screen time - or you could sell a paid app - but that's not without its challenges. A lot of mobile users will want to be able to try your app just so they can work out if it's worth their while. This would perhaps mean publishing a trial version of your app and then subtly diverting these users to a paid version - but this does mean you'd have to then publish two versions of your app - however, you're still splitting your audience across two apps - this means splitting your ratings, downloads and app indexation on the Play store!"),Object(a.b)("h1",null,"Best of both worlds."),Object(a.b)("p",null,"There is a better way. You can combine these two monetisation models by building a single version of your app and introducing paid features in your app - by using the ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://developer.android.com/google/play/billing/index.html"}),"Android's In-App Billing API")," - and its super easy to implement. There are a couple of things you'll want to work out first though - for example whether you want to charge your users with a subscription model i.e. something a media service would charge its users every month or over some other pre-determined amount of time, or have a consumable feature - i.e. something like ammo in a game - but in this particular example we're going to be focussing on having a perpetually unlockable feature which really is a baseline implementation of the lot."),Object(a.b)("h1",null,"Let's give it a go."),Object(a.b)("p",null,"The ",Object(a.b)("inlineCode",{parentName:"p"},"BillingClient")," convenience class provides a gateway into the ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://developer.android.com/google/play/billing/billing_library.html"}),"Play Billing Library")," and abstracts away calls to the ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://developer.android.com/google/play/billing/api.html"}),"In-App billing API")," for us. Here's how to leverage it:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("p",{parentName:"li"},"First we need to get an ",Object(a.b)("inlineCode",{parentName:"p"},"instance")," of the ",Object(a.b)("inlineCode",{parentName:"p"},"BillingClient"),". There is a convenience ",Object(a.b)("inlineCode",{parentName:"p"},"Builder")," class that requires the calling Activity's ",Object(a.b)("inlineCode",{parentName:"p"},"Context"),". We can also set the ",Object(a.b)("inlineCode",{parentName:"p"},"PurchasesUpdatedListener")," callback here which is important because we want to be notified of when the billing flow is complete and the user has been charged of course!"),Object(a.b)("pre",{parentName:"li"},Object(a.b)("code",Object.assign({parentName:"pre"},{}),"mBillingClient = BillingClient.newBuilder(mContext)\n               .setListener(this)\n               .build();\n"))),Object(a.b)("li",{parentName:"ul"},Object(a.b)("p",{parentName:"li"},"Let's take a quick detour and also update our permissions to use ",Object(a.b)("inlineCode",{parentName:"p"},"In-App Billing")," in our ",Object(a.b)("inlineCode",{parentName:"p"},"AndroidManifest.xml")," file."),Object(a.b)("pre",{parentName:"li"},Object(a.b)("code",Object.assign({parentName:"pre"},{}),'<uses-permission android:name="com.android.vending.BILLING" />\n'))),Object(a.b)("li",{parentName:"ul"},Object(a.b)("p",{parentName:"li"},"We set up the ",Object(a.b)("inlineCode",{parentName:"p"},"PurchasesUpdatedListener")," previously - so, when the ",Object(a.b)("inlineCode",{parentName:"p"},"onPurchasesUpdated")," callback gets notified - there are a couple of things to check. Firstly, there is an integer value ",Object(a.b)("inlineCode",{parentName:"p"},"responseCode"),". You can read about what ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://developer.android.com/reference/com/android/billingclient/api/BillingClient.BillingResponse.html"}),"responseCode")," means but for now, we're looking for ",Object(a.b)("inlineCode",{parentName:"p"},"BillingResponse.OK"),". Secondly, a ",Object(a.b)("inlineCode",{parentName:"p"},"@nullable List<Purchase>")," value - we can iterate over all of its values and look for particular ",Object(a.b)("inlineCode",{parentName:"p"},"skus")," - more on this later. Because ",Object(a.b)("inlineCode",{parentName:"p"},"List<Purchas>")," is nullable, its always a good idea to guard it with a null check of course and then iterate over to see if the required ",Object(a.b)("inlineCode",{parentName:"p"},"sku")," has been returned."),Object(a.b)("pre",{parentName:"li"},Object(a.b)("code",Object.assign({parentName:"pre"},{}),"if (purchases.size() > 0) {\n                for (Purchase result : purchases) {\n                    if (result.getSku().equals(mContext.getResources().getString(skuOfInterest))) {\n                        //the billing flow has completed successfully.\n                    }\n                }\n            }\n"))),Object(a.b)("li",{parentName:"ul"},Object(a.b)("p",{parentName:"li"},"Sweet. Now, we're Ok to go ahead and connect up our ",Object(a.b)("inlineCode",{parentName:"p"},"mBillingClient"),", we've previously built and added a callback to. We are required to pass in a ",Object(a.b)("inlineCode",{parentName:"p"},"BillingClientStateListener"),". Basically, this callback comes back with a integer value ",Object(a.b)("inlineCode",{parentName:"p"},"BillingResponse")," code which helps us determine if connnectivity was successful or not. There is also a ",Object(a.b)("inlineCode",{parentName:"p"},"onBillingServiceDisconnected")," method which is needed to be queried and consequently we need to return some meaningful feedback error to the user if required."),Object(a.b)("pre",{parentName:"li"},Object(a.b)("code",Object.assign({parentName:"pre"},{}),"mBillingClient.startConnection(new BillingClientStateListener() {\n        @Override\n        public void onBillingSetupFinished(int responseCode) {\n            if (responseCode == BillingClient.BillingResponse.OK) {\n                mIsBillingClientConnected = true;\n                //do other interesting things here - as we're connected now.\n            }\n        }\n\n        @Override\n        public void onBillingServiceDisconnected() {\n           mIsBillingClientConnected = false;\n           //handle this failure gracefully.\n       }\n    }\n")),Object(a.b)("p",{parentName:"li"},"now we know that we can query the In-App billing API when ",Object(a.b)("inlineCode",{parentName:"p"},"mIsBillingClientConnected")," is ",Object(a.b)("inlineCode",{parentName:"p"},"true")," and gracefully try either reconnecting or show an error response of sorts when it is ",Object(a.b)("inlineCode",{parentName:"p"},"false"),".")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("p",{parentName:"li"},"Now we've mentioned ",Object(a.b)("inlineCode",{parentName:"p"},"sku"),"s a few times in previous steps. This is just a ",Object(a.b)("inlineCode",{parentName:"p"},"String")," value that an ",Object(a.b)("strong",{parentName:"p"},"In-App product")," gets given when we generate one. Let's explore this here - we'll add an ",Object(a.b)("strong",{parentName:"p"},"In-app product")," that we can bill against."),Object(a.b)("p",{parentName:"li"},"On the ",Object(a.b)("strong",{parentName:"p"},"Play Console"),", under ",Object(a.b)("strong",{parentName:"p"},"Store Presence"),", there is an option to create ",Object(a.b)("strong",{parentName:"p"},"In-App products")," click on ",Object(a.b)("strong",{parentName:"p"},"Add a Managed Product")," - then give it an id (only underscores, lowercase letters and digits allowed!) - which will become the ",Object(a.b)("inlineCode",{parentName:"p"},"sku")," for your ",Object(a.b)("strong",{parentName:"p"},"In-App Product")),Object(a.b)("p",{parentName:"li"},"Next, give it a title and a description as well as price. This will show up when a user tries to buy your In-app product through your app, so make it short and simple. The Play console does automatic currency conversions for countries your app is supported in - so if you need to tweak that for individual countries - you can it here as well. Finally, click  on save and it will add your ",Object(a.b)("inlineCode",{parentName:"p"},"In-App product"),"."),Object(a.b)("p",{align:"center"},Object(a.b)("img",{src:"../images/billing/in-app-products.png"})),Object(a.b)("p",{align:"center"},Object(a.b)("img",{src:"../images/billing/add-product.png"})),Object(a.b)("p",{parentName:"li"},"Now that you've got an ",Object(a.b)("inlineCode",{parentName:"p"},"sku"),", you can create a ",Object(a.b)("inlineCode",{parentName:"p"},"@StringRes")," for it."),Object(a.b)("pre",{parentName:"li"},Object(a.b)("code",Object.assign({parentName:"pre"},{}),'<string name="id_sku_my_product">01_my_first_product</string>\n'))),Object(a.b)("li",{parentName:"ul"},Object(a.b)("p",{parentName:"li"},"Nearly there! Now you can query for if the user has purchased your ",Object(a.b)("strong",{parentName:"p"},"In-App Product"),". This is determined by running the ",Object(a.b)("inlineCode",{parentName:"p"},"queryPurchaseHistoryAsync")," callback on your ",Object(a.b)("inlineCode",{parentName:"p"},"mBillingClient"),"."),Object(a.b)("pre",{parentName:"li"},Object(a.b)("code",Object.assign({parentName:"pre"},{}),"mBillingClient.queryPurchaseHistoryAsync(BillingClient.SkuType.INAPP,\n             new PurchaseHistoryResponseListener() {\n                 @Override\n                 public void onPurchaseHistoryResponse(@BillingClient.BillingResponse int responseCode,\n                                                       List<Purchase> purchasesList) {\n                     if (responseCode == BillingClient.BillingResponse.OK) {\n                         if (purchasesList != null) {\n                             if (purchasesList.size() > 0) {\n                                 for (Purchase result : purchasesList) {\n                                     if (result.getSku().equals(mContext.getResources().getString(R.string.01_my_first_product))) {\n                                         //success! your user has bought your In-App product. Woohoo!\n                                     }\n                                 }\n\n                             }\n                         }\n                     }\n                 }\n             });\n"))),Object(a.b)("li",{parentName:"ul"},Object(a.b)("p",{parentName:"li"},"Although, Android gives you some more convenience on top of this. You do not need to call ",Object(a.b)("inlineCode",{parentName:"p"},"queryPurchaseHistoryAsync")," everytime. Purchases are cached by the Play store app - so you can just run ",Object(a.b)("inlineCode",{parentName:"p"},"queryPurchases"),". So, what naturally follows is that you would use this call to see if it comes back with legit ",Object(a.b)("inlineCode",{parentName:"p"},"PurchaseResult"),", if not you can run  ",Object(a.b)("inlineCode",{parentName:"p"},"queryPurchaseHistoryAsync"),"."),Object(a.b)("pre",{parentName:"li"},Object(a.b)("code",Object.assign({parentName:"pre"},{}),"Purchase.PurchasesResult purchasesResult = mBillingClient.queryPurchases(BillingClient.SkuType.INAPP);\n                  if (purchasesResult != null) {\n                      if (purchasesResult.getPurchasesList() != null) {\n                          if (purchasesResult.getPurchasesList().size() > 0) {\n                              for (Purchase result : purchasesResult.getPurchasesList()) {\n                                  if (result.getSku().equals(mContext.getResources().getString(R.string.01_my_first_product))) {\n                                      //success! your user has bought your In-App product. Wowie!\n                                  }\n                              }\n                          }\n                      }\n                  }\n"))),Object(a.b)("li",{parentName:"ul"},Object(a.b)("p",{parentName:"li"},"Ok, so that's the basic flow. Let's recap:"),Object(a.b)("ol",{parentName:"li"},Object(a.b)("li",{parentName:"ol"},"Build the ",Object(a.b)("inlineCode",{parentName:"li"},"BillingClient"),"."),Object(a.b)("li",{parentName:"ol"},"Connect said ",Object(a.b)("inlineCode",{parentName:"li"},"BillingClient"),"."),Object(a.b)("li",{parentName:"ol"},"On success, pass in the ",Object(a.b)("inlineCode",{parentName:"li"},"purchasesUpdatedListener")," callback."),Object(a.b)("li",{parentName:"ol"},"When purchases are updated query for your ",Object(a.b)("inlineCode",{parentName:"li"},"sku")," by running first running ",Object(a.b)("inlineCode",{parentName:"li"},"queryPurchases")," or ",Object(a.b)("inlineCode",{parentName:"li"},"queryPurchaseHistoryAsync"),".")),Object(a.b)("p",{parentName:"li"},"But what about users that have already bought your product? Well, you'll have to run this process at the start of your app too! Users that have already bought your app don't need to be run through a purchase process of course!"))),Object(a.b)("h1",null,"Optimisation tips."),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("p",{parentName:"li"},"It almost seems like you're going to have to follow the billing process twice. You're just better off using a ",Object(a.b)("inlineCode",{parentName:"p"},"Singleton")," instance of the ",Object(a.b)("inlineCode",{parentName:"p"},"BillingClient"),". If you're using a DI framework like the excellent ",Object(a.b)("a",Object.assign({parentName:"p"},{href:"https://google.github.io/dagger/"}),"Dagger"),", you're better off creating a ",Object(a.b)("inlineCode",{parentName:"p"},"Singleton")," component on your dependency graph and then injecting it as needed.")),Object(a.b)("li",{parentName:"ul"},Object(a.b)("p",{parentName:"li"},"One of the biggest challenges for me was the fact that ",Object(a.b)("inlineCode",{parentName:"p"},"In-App Billing")," was not showing up on the Play console. That'd be because my production APK didn't have the In-App billing permissions. This is easily remedied by creating an Alpha release of your app - and actually its highly recommended because you can then use test accounts to test the purchase flows. As long as your test users are added as alpha testers for your app!"),Object(a.b)("p",{parentName:"li"},Object(a.b)("strong",{parentName:"p"},"Questions? Suggestions? Compliments? Tips to make this post better? I'd love to hear your thoughts! Join the conversation on twitter and tweet to ",Object(a.b)("a",Object.assign({parentName:"strong"},{href:"https://twitter.com/overjeer"}),"@overjeer")))))))}s.isMDXComponent=!0},zLVn:function(e,t,n){"use strict";function i(e,t){if(null==e)return{};var n,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}n.d(t,"a",(function(){return i}))}}]);
//# sourceMappingURL=component---src-pages-2017-12-09-app-monetisation-and-in-app-billing-implementation-mdx-bf066bd9721196776643.js.map