---
slug: "2022-03-17-Firebase-remove-unused-push-tokens"
title:  "Invalidating unused Firebase push tokens using scheduled functions"
date:   2022-03-17 21:30 +1100
categories: "blog"
---

<div className="blogpage">
    <a href={"/blog"} smooth duration={1000}>
    {"Back"}
    </a>
</div>

<div className="blogText">

<p> Invalidating unused Firebase push tokens using scheduled functions </p>

<br/>
<br/>

Push messaging in modern mobile apps with Firebase is really common. The usual workflow is:

- Integrating Firebase push SDKs / Cocoapods / SPM packages within the app.

- Registering a project on the Firebase console.

- On native apps, configuring the Firebase library, requesting for notification permissions, obtaining push tokens and saving them to a backend service.


A lot of apps obtain push tokens at login (an optimal way of doing this is by requesting the current token from Firebase's local cache). Apps that support multiple users / login, usually also invalidate tokens on logout. 
But what if the user never logs out, but removes / uninstall the app? ü§î

The best way to invalidate these tokens, unfortunately is by looking for errors when a push message is sent outbound, like so:

```js
admin.messaging().sendToDevice(tokens, message, options)
    .then((response) => {
        console.log('Successfully sent message:', response);
    }).catch((error) => {
        if (error.code === 'messaging/invalid-registration-token' ||
            error.code === 'messaging/registration-token-not-registered') {
            //a promise here to delete the token which can be pushed to an array,
            //then return promise.all üëç
        }
    });
```

This is however problematic in apps that a) don't want to send out bulk outbound notifications and b) only support async notifications ie. notifications that go out when the 
user performs an action.


There's a better way. On closely inspecting the way Firebase functions sends out push notifications, I realised there is a 


```js
sendToDevice(registrationToken: string | string[], payload: MessagingPayload, options?: MessagingOptions): Promise<MessagingDevicesResponse>;
```

Here, `MessagingOptions` has a `dryRun?: boolean` variable, when set to true, it won't actually send the push message but rather do a dry run.


Essentially, how we can create a [scheduled](https://firebase.google.com/docs/functions/schedule-functions) Firebase function that:
a) Polls for all push tokens

```js
for (const [key, value] of tokens.entries()) {
        allTokens.push(key);
}
```

b) sets dry run to true.

```js
    const options = {
        dryRun: true
    }

```

c)  Finally, send out push notifications, poll for errors and remove invalid tokens:

```js
    admin.messaging().sendToDevice(allTokens, message, options)
    .then((response) => {
        response.results.forEach((deviceResult, index) => {
            if (deviceResult.error) {
                let failedToken = allTokens[index];
                //push a promise to remove token from db.
            }
        });
    });
    return Promise.all(tokensToRemove);

```


</div>