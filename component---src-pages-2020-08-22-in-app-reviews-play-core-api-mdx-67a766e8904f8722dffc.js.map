{"version":3,"sources":["webpack:///./src/pages/2020-08-22-In-App-Reviews-PlayCore-API.mdx","webpack:///./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js"],"names":["_frontmatter","layoutProps","MDXContent","components","props","mdxType","className","href","smooth","duration","parentName","align","width","controls","autostart","autoPlay","src","review_test","type","isMDXComponent","_objectWithoutPropertiesLoose","source","excluded","key","i","target","sourceKeys","Object","keys","length","indexOf"],"mappings":"sQAQaA,EAAe,CAC1B,KAAQ,yCACR,MAAS,qDACT,KAAQ,0BAEJC,EAAc,CAClBD,gBAGa,SAASE,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,EACF,iBACD,OAAO,YALS,UAKT,iBAAeH,EAAiBG,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAE5E,mBAAKC,UAAU,YACf,iBAAGC,KAAM,QAASC,QAAM,EAACC,SAAU,KAClC,SAGD,mBAAKH,UAAU,YACb,4EACA,uBACA,uBACA,6TAEA,uBAAK,oBAAMI,WAAW,OAAjB,8WAcL,gDACA,gOACA,6DAA4C,0BAAYA,WAAW,KAAvB,YAA5C,+BAAgI,0BAAYA,WAAW,KAAvB,gBAAhI,qGACA,2CACA,uBAAK,oBAAMA,WAAW,OAAjB,0DAEL,2UAA0T,0BAAYA,WAAW,KAAvB,2BAA1T,4TAA0rB,0BAAYA,WAAW,KAAvB,2BAA1rB,2IAAy4B,0BAAYA,WAAW,KAAvB,WAAz4B,WACA,wCACA,sEAAqD,0BAAYA,WAAW,KAAvB,eAArD,wBAAqI,0BAAYA,WAAW,KAAvB,eAArI,yKACA,uBAAK,oBAAMA,WAAW,OAAjB,wXAYL,gOACA,oDAAmC,0BAAYA,WAAW,KAAvB,wBAAnC,iCAAqI,0BAAYA,WAAW,KAAvB,iBAArI,KACA,mFAAkE,0BAAYA,WAAW,KAAvB,QAAlE,kBAAqI,0BAAYA,WAAW,KAAvB,oBAArI,eACA,+CAA8B,0BAAYA,WAAW,KAAvB,uBAA9B,cAA4G,0BAAYA,WAAW,KAAvB,sBAA5G,0BAAqM,0BAAYA,WAAW,KAAvB,QAArM,2FAAiV,0BAAYA,WAAW,KAAvB,eAAjV,KACA,6FACA,uBAAK,oBAAMA,WAAW,OAAjB,uRAUL,uFAAsE,0BAAYA,WAAW,KAAvB,iBAAtE,sBAAsJ,0BAAYA,WAAW,KAAvB,cAAtJ,sBAAmO,0BAAYA,WAAW,KAAvB,uBAAnO,wBAA2T,0BAAYA,WAAW,KAAvB,uBAC3T,uBAAK,oBAAMA,WAAW,OAAjB,wuBAeL,iCACA,sBACE,kBAAIA,WAAW,MACb,iBAAGA,WAAW,MAAd,kFAAsG,0BAAYA,WAAW,KAAvB,0BAAtG,sRAEF,kBAAIA,WAAW,MACb,iBAAGA,WAAW,MAAd,2CAA+D,sBAAQA,WAAW,KAAnB,oBAA/D,SAEF,kBAAIA,WAAW,MACb,iBAAGA,WAAW,MAAd,iFAEF,kBAAIA,WAAW,MACb,iBAAGA,WAAW,MAAd,iEAAqF,sBAAQA,WAAW,KAAnB,SAArF,uEAAsM,0BAAYA,WAAW,KAAvB,oBAAtM,+DAEF,kBAAIA,WAAW,MACb,iBAAGA,WAAW,MAAd,qCAAyD,0BAAYA,WAAW,KAAvB,SAAzD,yDAAoK,0BAAYA,WAAW,KAAvB,QAApK,qFAGJ,mBAAKC,MAAM,UACb,qBAAOC,MAAM,MAAMC,UAAQ,EAACC,WAAS,EAACC,UAAQ,EAACC,IAAKC,IAAaC,KAAK,iBAO1EhB,EAAWiB,gBAAiB,G,kCC9Hb,SAASC,EAA8BC,EAAQC,GAC5D,GAAc,MAAVD,EAAgB,MAAO,GAC3B,IAEIE,EAAKC,EAFLC,EAAS,GACTC,EAAaC,OAAOC,KAAKP,GAG7B,IAAKG,EAAI,EAAGA,EAAIE,EAAWG,OAAQL,IACjCD,EAAMG,EAAWF,GACbF,EAASQ,QAAQP,IAAQ,IAC7BE,EAAOF,GAAOF,EAAOE,IAGvB,OAAOE,EAZT","file":"component---src-pages-2020-08-22-in-app-reviews-play-core-api-mdx-67a766e8904f8722dffc.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\n\nimport review_test from './images/review_test.mp4';\nexport const _frontmatter = {\n  \"slug\": \"2020-08-22-In-App-Reviews-PlayCore-API\",\n  \"title\": \"Finally! In-App Reviews for Android using Playcore\",\n  \"date\": \"2020-08-22 14:00 +1100\"\n};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = \"wrapper\";\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n    <div className=\"blogpage\">\n    <a href={\"/blog\"} smooth duration={1000}>\n    {\"Back\"}\n    </a>\n    </div>\n    <div className=\"blogText\">\n      <h1>{`Finally! In-App Reviews for Android using Playcore`}</h1>\n      <br />\n      <br />\n      <p>{`One of the coolest things about writing iOS apps are it's high-level APIs, for example one of my favourite things is how you can prompt the user to leave a review\nwithout getting them to ever leave your app. The best part of this? The code to request a review is ALSO super concise, like so:`}</p>\n      <pre><code parentName=\"pre\" {...{}}>{`import StoreKit\n\nclass SomeViewController: UIViewController {\n        override func viewDidLoad() {\n        super.viewDidload()\n        if (shouldShowRatingDialog) {\n            //does anyone even still run iOS 10.3? ü§î\n            if #available( iOS 10.3,*){\n                SKStoreReviewController.requestReview()\n            }\n        }\n    }\n}\n`}</code></pre>\n      <p>{`See how easy that is ü§©`}</p>\n      <p>{`Well, until just recently this was not even possible in Android. But with the new Playcore API, this is totally doable and even though not as easy as it's iOS counterpart, it's not super difficult. ‚úÖ`}</p>\n      <p>{`To get started, we first pull in the `}<inlineCode parentName=\"p\">{`PlayCore`}</inlineCode>{` library into our app level `}<inlineCode parentName=\"p\">{`build.gradle`}</inlineCode>{`'s dependencies block. This can of course be different if you define your dependencies elsewhere.`}</p>\n      <h3>{`Gradle dependency`}</h3>\n      <pre><code parentName=\"pre\" {...{}}>{`implementation 'com.google.android.play:core:1.8.0'\n`}</code></pre>\n      <p>{`Next steps include thinking about how this screen can be presented to the end users. For example - presenting this option excessively might drive users away from reviewing your app, or worse yet, away from your app. The good thing about the StoreKit API on iOS is, you can just make the call to present the `}<inlineCode parentName=\"p\">{`SKStoreReviewController`}</inlineCode>{` and it automatically caps how often it appears for the user. Well, fret not, even the PlayCore In-app reviews API does this for us! This however, is a double-edged sword because when we first implement areas in our apps or games to prompt the user for a review, we want to ensure that it works! Well, on iOS the `}<inlineCode parentName=\"p\">{`SKStoreReviewController`}</inlineCode>{` actually always appears in a test build of the app, however on Android it's a little bit more complicated. More on that when we get to `}<inlineCode parentName=\"p\">{`Testing`}</inlineCode>{` below.`}</p>\n      <h3>{`Implementation`}</h3>\n      <p>{`To show users the prompt, I create a blocking `}<inlineCode parentName=\"p\">{`ProgressBar`}</inlineCode>{`, contained within a `}<inlineCode parentName=\"p\">{`Framelayout`}</inlineCode>{` like so. This is just an example, but it makes sense because the API is asynchronous, so there is a little bit of waiting for the user before the prompt can appear.`}</p>\n      <pre><code parentName=\"pre\" {...{}}>{`<FrameLayout\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\">\n\n        <ProgressBar\n            android:id=\"@+id/progress_vocab_term\"\n            android:layout_width=\"48dp\"\n            android:layout_height=\"48dp\"\n            android:layout_gravity=\"center\"\n            android:visibility=\"gone\" />\n    </FrameLayout>\n`}</code></pre>\n      <p>{`As a rule of thumb, this can be presented when the user is already waiting for a screen to load within a game - such as a transition between level ups, or in my case, a slang term to finish loading! `}</p>\n      <p>{`The Playcore API gives us a `}<inlineCode parentName=\"p\">{`ReviewManagerFactory`}</inlineCode>{` to create an instance of the `}<inlineCode parentName=\"p\">{`ReviewManager`}</inlineCode>{`.`}</p>\n      <p>{`Called within an activity or a fragment, we can either use `}<inlineCode parentName=\"p\">{`this`}</inlineCode>{` (Activity) or `}<inlineCode parentName=\"p\">{`requireContext()`}</inlineCode>{` (Fragment)`}</p>\n      <p>{`Once available, we can `}<inlineCode parentName=\"p\">{`requestReviewFlow()`}</inlineCode>{` and add a `}<inlineCode parentName=\"p\">{`completionListener`}</inlineCode>{` as this is a deferred `}<inlineCode parentName=\"p\">{`Task`}</inlineCode>{`, because of asynchronous nature. This is also about the time you would show a blocking `}<inlineCode parentName=\"p\">{`ProgressBar`}</inlineCode>{`.`}</p>\n      <p>{`This can be abstracted into a function that takes a boolean like so:`}</p>\n      <pre><code parentName=\"pre\" {...{}}>{`fun toggleProgressBar(visible: Boolean) {\n    if (visible) {\n        progress_bar.visibility = View.Visible\n        content_view.visibility = View.Gone\n    } else {\n        progress_bar.visibility = View.Gone\n        contente_view.visibility = View.Visible\n    }\n}\n`}</code></pre>\n      <p>{`Now we can start our In-app Review flow, first by grabbing the `}<inlineCode parentName=\"p\">{`ReviewManager`}</inlineCode>{` then requesting a `}<inlineCode parentName=\"p\">{`ReviewInfo`}</inlineCode>{` object by calling `}<inlineCode parentName=\"p\">{`requestReviewFlow()`}</inlineCode>{`, then passing it to `}<inlineCode parentName=\"p\">{`launchReviewFlow()`}</inlineCode></p>\n      <pre><code parentName=\"pre\" {...{}}>{`        val reviewManager = ReviewManagerFactory.create(this)\n        toggleProgressBar(visible = true)\n        reviewManager.requestReviewFlow().addOnCompleteListener {\n            if (it.isComplete) {\n                val info = it.result //your reviewInfo object\n                reviewManager.launchReviewFlow(this, info).addOnCompleteListener { \n                    //the flow completed successfully. The user either left you a review üëçüèΩ or dismissed the review prompt üôÄ\n                    toggleProgressBar(visible = false) \n                }\n            } else {\n                //something went wrong, the review flow couldn't be completed\n                toggleProgressBar(visible = false)\n            }\n        }\n`}</code></pre>\n      <h3>{`Testing`}</h3>\n      <ul>\n        <li parentName=\"ul\">\n          <p parentName=\"li\">{`Testing this behaviour is a little bit tricky. The easiest way is to create an `}<inlineCode parentName=\"p\">{`Internal Testing Track`}</inlineCode>{` build and rollout to your internal testers. I know this sounds like a bit of work but in practice this is super quick! Internal testing builds are available to testers within a few minutes of uploading (unless it's the first ever build, which can take up to 48 hours!). üëã`}</p>\n        </li>\n        <li parentName=\"ul\">\n          <p parentName=\"li\">{`Once the tester gets the build, you can `}<strong parentName=\"p\">{`run local builds`}</strong>{`! üëè`}</p>\n        </li>\n        <li parentName=\"ul\">\n          <p parentName=\"li\">{`In the testing track builds the review prompt has no quotas so test away! üöó`}</p>\n        </li>\n        <li parentName=\"ul\">\n          <p parentName=\"li\">{`If a testing user leaves a review during the test, the prompt `}<strong parentName=\"p\">{`won't`}</strong>{` show again. But the tester can just as easily go to the Play store `}<inlineCode parentName=\"p\">{`Internal Testing`}</inlineCode>{` build and remove their review to re-enable the prompt! ü§ù`}</p>\n        </li>\n        <li parentName=\"ul\">\n          <p parentName=\"li\">{`I would not recommend creating an `}<inlineCode parentName=\"p\">{`Alpha`}</inlineCode>{` track build! These go through reviews! And of course `}<inlineCode parentName=\"p\">{`Beta`}</inlineCode>{` track is open to everyone in the world, so definitely also not recommended. üö´`}</p>\n        </li>\n      </ul>\n      <div align=\"center\">\n    <video width=\"30%\" controls autostart autoPlay src={review_test} type=\"video/mp4\" />\n      </div>\n    </div>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      ","export default function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}"],"sourceRoot":""}